#####################################################################
#
# CSC258H5S Fall 2021 Assembly Final Project
# University of Toronto, St. George
#
# Student: Idris Tarwala, 1006896780
#
# Bitmap Display Configuration:
# - Unit width in pixels: 8
# - Unit height in pixels: 8
# - Display width in pixels: 256
# - Display height in pixels: 256
# - Base Address for Display: 0x10008000 ($gp)
#
# Which milestone is reached in this submission?
# 
# - Milestone 2

#####################################################################

.data
displayAddress: .word 0x10008000
frogLocation: .word 3648
initialCarPosition: .word 
intialLogPosition: .word 
carRow1: .word 0xC10303,0xC10303,0xC10303,0xC10303,0xC10303,0xC10303,0xC10303,0xC10303,0x3A3A3A,0x3A3A3A,0x3A3A3A,0x3A3A3A,0x3A3A3A,0x3A3A3A,0x3A3A3A,0x3A3A3A,0xC10303,0xC10303,0xC10303,0xC10303,0xC10303,0xC10303,0xC10303,0xC10303,0x3A3A3A,0x3A3A3A,0x3A3A3A,0x3A3A3A,0x3A3A3A,0x3A3A3A,0x3A3A3A,0x3A3A3A
carRow2: .word 0x3A3A3A,0x3A3A3A,0x3A3A3A,0x3A3A3A,0xC10303,0xC10303,0xC10303,0xC10303,0xC10303,0xC10303,0xC10303,0xC10303,0x3A3A3A,0x3A3A3A,0x3A3A3A,0x3A3A3A,0x3A3A3A,0x3A3A3A,0x3A3A3A,0x3A3A3A,0xC10303,0xC10303,0xC10303,0xC10303,0xC10303,0xC10303,0xC10303,0xC10303,0x3A3A3A,0x3A3A3A,0x3A3A3A,0x3A3A3A
logRow1: .word 0x00F0FF,0x00F0FF,0x00F0FF,0x00F0FF,0x00F0FF,0x00F0FF,0x00F0FF,0x00F0FF,0xCC5C3E,0xCC5C3E,0xCC5C3E,0xCC5C3E,0xCC5C3E,0xCC5C3E,0xCC5C3E,0xCC5C3E,0x00F0FF,0x00F0FF,0x00F0FF,0x00F0FF,0x00F0FF,0x00F0FF,0x00F0FF,0x00F0FF,0xCC5C3E,0xCC5C3E,0xCC5C3E,0xCC5C3E,0xCC5C3E,0xCC5C3E,0xCC5C3E,0xCC5C3E
logRow2: .word 0x00F0FF,0x00F0FF,0x00F0FF,0x00F0FF,0xCC5C3E,0xCC5C3E,0xCC5C3E,0xCC5C3E,0xCC5C3E,0xCC5C3E,0xCC5C3E,0xCC5C3E,0x00F0FF,0x00F0FF,0x00F0FF,0x00F0FF,0x00F0FF,0x00F0FF,0x00F0FF,0x00F0FF,0xCC5C3E,0xCC5C3E,0xCC5C3E,0xCC5C3E,0xCC5C3E,0xCC5C3E,0xCC5C3E,0xCC5C3E,0x00F0FF,0x00F0FF,0x00F0FF,0x00F0FF
.text


main:	
	DefaultPosition:
	#load variables
	lw $s4, frogLocation
	la $s3, carRow1
	la $s2, carRow2
	la $s1, logRow1
	la $s0, logRow2
	li $s7, 0   # value of 1 if collision occurs
	
	StartHere: #start loop here
	
	jal drawBackground # first draw background
	
	jal drawAllCars # next draw cars 

	jal drawAllLogs # then draw logs3
	
	#next we want to shift the arrays and move obstacles
	
	addi $sp, $sp, -4  #move stack pointer one word and store carrow1
	sw $s3, 0($sp) 
	jal ShiftArrayLeft
	
	addi $sp, $sp, -4 # move stack pointer one word and store logrow2
	sw $s0, 0($sp) 
	jal ShiftArrayLeft
	
	addi $sp, $sp, -4 # move stack pointer one word and store logrow1
	sw $s1, 0($sp)
	jal shiftArrayRight
	
	addi $sp, $sp, -4 # move stack pointer one word and store carrow2
	sw $s2, 0($sp) 
	jal shiftArrayRight
	
	#listen for input
	
	lw $t8, 0xffff0000
	beq $t8, 1, keyboard_input
	j ENDLISTEN
	
	
	keyboard_input:
	lw $t2, 0xffff0004
	beq $t2, 0x77, respond_to_w
	beq $t2, 0x61, respond_to_a
	beq $t2, 0x73, respond_to_s
	beq $t2, 0x64, respond_to_d
	beq $t2, 0x64, respond_to_d
	beq $t2, 0x71, respond_to_q
	
	respond_to_w:
	
	subi $s4, $s4, 512
	j ENDLISTEN
	
	respond_to_a:
	
	subi $s4, $s4, 16
	j ENDLISTEN
	
	respond_to_s:
	
	addi $s4, $s4, 512
	j ENDLISTEN
	
	respond_to_d:
	
	addi $s4, $s4, 16
	j ENDLISTEN
	
	respond_to_q:
	
	j Exit
	
	ENDLISTEN:
	
	#check for collisions
	
	addi $sp, $sp, -4  #move stack pointer one word and store carrow1
	sw $s4, 0($sp)
	jal checkCollisionCar
	beq $s7, 1, DefaultPosition  #if 1, collision has occured and want to change state of game
	
	addi $sp, $sp, -4  #move stack pointer one word and store carrow1
	sw $s4, 0($sp)
	jal checkCollisionWater
	beq $s7, 1, DefaultPosition  #if 1, collision has occured and want to change state of game
	

	DrawingFrog:
	# draw frog with given position
	addi $sp, $sp, -4  #move stack pointer one word and store carrow1
	sw $s4, 0($sp)
	jal drawFrog
	
	#check if frog is on log, if so, then shift to the left or right	:
	
	add $t0, $t0, $s4 # jump to position
	#want to check if its on a log
	lw $t8, 0($t0) # load current color
	lw $t9, -4($t0) # load color to the left of frog
	lw $t7, 20($t0) # load color to the right of frog
	# if either one is brown, then frog is on a log
	beq $t9, 0xCC5C3E , shiftFrogWithLog
	beq $t7, 0xCC5C3E , shiftFrogWithLog
	j Sleep
	
	shiftFrogWithLog:
	
	jal frogShift
	j Sleep

	Sleep:
	li $v0, 32
	li $a0, 1000
	syscall
	
	j StartHere

	
drawBackground:

	lw $t0, displayAddress # $t0 stores the base address for display
	li $t1, 0xE5D14F # $t1 stores the mud colour code
	li $t2, 0x62ED08 # $t2 stores the green colour code
	li $t3, 0x00F0FF  # $t3 stores the blue colour code
	li $t6, 0x3A3A3A # $t6 stores the gray color
	li $t4, 4 #increment position by 4
	li $t5, 0 #pixel position

	paintSafe: 
	sw $t2,0($t0)
	add $t0, $t0, $t4
	add $t5, $t5, $t4 #increment pixel position
	beq $t5, 1024, paintWaterUp
	j paintSafe

	paintWaterUp:
	sw $t3,0($t0)
	add $t0, $t0, $t4
	add $t5, $t5, $t4 #increment pixel position
	beq $t5, 2048, paintMiddleGround
	j paintWaterUp

	paintMiddleGround:
	sw $t1,0($t0)
	add $t0, $t0, $t4
	add $t5, $t5, $t4 #increment pixel position
	beq $t5, 2560, paintRoad
	j paintMiddleGround

	paintRoad:
	sw $t6, 0($t0)
	add $t0, $t0, $t4
	add $t5, $t5, $t4 #increment pixel position
	beq $t5, 3584, paintStart
	j paintRoad

	paintStart:
	sw $t2,0($t0)
	add $t0, $t0, $t4
	add $t5, $t5, $t4 #increment pixel position
	beq $t5, 4096, resetDP
	j paintStart

	resetDP:
	lw $t0, displayAddress 
	jr $ra


drawFrog:
	li $t8, 0xFF0080
	lw $a0, 0($sp) # pop frog coordinte parameter
	addi $sp, $sp, 4 # increase length of stack
	add $t0, $t0, $a0 # jump to position
	
	li $t1, 0 # horizontal counter
	li $t2, 0 # vertical counter
	FrogLoop: # create frog shape, square for now
	sw $t8, 0($t0) # create a row
	addi $t1, $t1, 4
	addi $t0, $t0, 4
	beq $t1, 16, nextRow
	j FrogLoop
	nextRow:
	add $t0, $t0, 112 # jump to next row and repeat
	li $t1, 0
	add $t2, $t2, 1
	beq $t2, 4, finish
	j FrogLoop
	
	finish:
	lw $t0, displayAddress #reset displayAddress to original value
	jr $ra

drawRow: # takes in an array of 32 colors and the starting position of the row
	add $t0, $t0, $a0 # jump to position
	
	loopInit:
	li $t4, 0 # t4 hold 4*i, intially at 0
	li $t5, 128
	
	rowLoop:
	bge, $t4, $t5, rowLoopEnd
	add $t3, $a1, $t4 #stores the address of a1[i]
	lw $t9, 0($t3) #contains the color to be painted
	
	sw $t9, 0($t0)
	addi $t0, $t0, 4 #increment position 
	addi $t4, $t4, 4 #incrememnt offset counter
	j rowLoop
	rowLoopEnd:
	lw $t0, displayAddress #reset displayAddress to original value
	jr $ra
	

drawAllCars:

	#draw the first row of cars 
	addi $sp, $sp, -4 # move stack pointer one word and store ra
	sw $ra, 0($sp)
	move $a1, $s3
	li $a0, 2560
	jal drawRow
	lw $ra, 0($sp) # restore ra from stack
	addi $sp, $sp, 4
	
	addi $sp, $sp, -4 # move stack pointer one word and store ra
	sw $ra, 0($sp)
	li $a0, 2688
	jal drawRow
	lw $ra, 0($sp) # restore ra from stack
	addi $sp, $sp, 4
	
	addi $sp, $sp, -4 # move stack pointer one word and store ra
	sw $ra, 0($sp)
	li $a0, 2816
	jal drawRow
	lw $ra, 0($sp) # restore ra from stack
	addi $sp, $sp, 4
	
	addi $sp, $sp, -4 # move stack pointer one word and store ra
	sw $ra, 0($sp)
	li $a0, 2944
	jal drawRow
	lw $ra, 0($sp) # restore ra from stack
	addi $sp, $sp, 4
	
	#draw the second row of cars
	addi $sp, $sp, -4 # move stack pointer one word and store ra
	sw $ra, 0($sp)
	move $a1, $s2
	li $a0, 3072
	jal drawRow
	lw $ra, 0($sp) # restore ra from stack
	addi $sp, $sp, 4
	
	addi $sp, $sp, -4 # move stack pointer one word and store ra
	sw $ra, 0($sp)
	li $a0, 3200
	jal drawRow
	lw $ra, 0($sp) # restore ra from stack
	addi $sp, $sp, 4
	
	addi $sp, $sp, -4 # move stack pointer one word and store ra
	sw $ra, 0($sp)
	li $a0, 3328
	jal drawRow
	lw $ra, 0($sp) # restore ra from stack
	addi $sp, $sp, 4
	
	addi $sp, $sp, -4 # move stack pointer one word and store ra
	sw $ra, 0($sp)
	li $a0, 3456
	jal drawRow	
	lw $ra, 0($sp) # restore ra from stack
	addi $sp, $sp, 4
	
	jr $ra
	
drawAllLogs:

	#draw the first row of logs 
	addi $sp, $sp, -4 # move stack pointer one word and store ra
	sw $ra, 0($sp)
	move $a1, $s0
	li $a0, 1024
	jal drawRow
	lw $ra, 0($sp) # restore ra from stack
	addi $sp, $sp, 4
	
	addi $sp, $sp, -4 # move stack pointer one word and store ra
	sw $ra, 0($sp)
	li $a0, 1152
	jal drawRow
	lw $ra, 0($sp) # restore ra from stack
	addi $sp, $sp, 4
	
	addi $sp, $sp, -4 # move stack pointer one word and store ra
	sw $ra, 0($sp)
	li $a0, 1280
	jal drawRow
	lw $ra, 0($sp) # restore ra from stack
	addi $sp, $sp, 4
	
	addi $sp, $sp, -4 # move stack pointer one word and store ra
	sw $ra, 0($sp)
	li $a0, 1408
	jal drawRow
	lw $ra, 0($sp) # restore ra from stack
	addi $sp, $sp, 4
	
	#draw the second row of cars
	addi $sp, $sp, -4 # move stack pointer one word and store ra
	sw $ra, 0($sp)
	move $a1, $s1
	li $a0, 1536
	jal drawRow
	lw $ra, 0($sp) # restore ra from stack
	addi $sp, $sp, 4
	
	addi $sp, $sp, -4 # move stack pointer one word and store ra
	sw $ra, 0($sp)
	li $a0, 1664
	jal drawRow
	lw $ra, 0($sp) # restore ra from stack
	addi $sp, $sp, 4
	
	addi $sp, $sp, -4 # move stack pointer one word and store ra
	sw $ra, 0($sp)
	li $a0, 1792
	jal drawRow
	lw $ra, 0($sp) # restore ra from stack
	addi $sp, $sp, 4
	
	addi $sp, $sp, -4 # move stack pointer one word and store ra
	sw $ra, 0($sp)
	li $a0, 1920
	jal drawRow	
	lw $ra, 0($sp) # restore ra from stack
	addi $sp, $sp, 4
	
	jr $ra

shiftArrayRight:
	
	lw $s6, 0($sp) # restore row address from stack
	addi $sp, $sp, 4
	
	addi $t1, $s6, 124 # the intial offset address, we will subtract 4 from this using $t3
	li $t2 , 124 # contains 4*i, we will subtract 4 from this until we reach 0
	li $t3, 0 # we will add 4 to this each time until we reach 128
	li $t8, 0
	lw $t8, 124($s6) # contains temp value for cr2[n - 1]
	
	Shift:
	bgtz $t2, FORLOOP
	
	#update final value
	lw $t9, 0($s6) # cr2[0]
	move $t9, $t8
	sw $t9, 0($s6)
	jr $ra 
	
	FORLOOP:
	sub $t4, $t1, $t3 # contains the address of cr2[i] starting at the end first
	subi $t6, $t4, 4 # contains the address of cr2[i - 1]
	lw $t5, 0($t4) #contains cr2[i]
	lw $t7, 0($t6) #contains cr2[i - 1]
	
	move $t5, $t7  # cr2[i] = cr2[i - 1]
	sw $t5, 0($t4) #  store cr2[i] = cr2[i - 1]
	
	subi $t2,$t2, 4 #update loop condition
	addi $t3,$t3, 4 #update offset
	j Shift
	
	
	
ShiftArrayLeft:
	
	lw $s5, 0($sp) # contains address of the array
	addi $sp, $sp, 4
	lw $t1, 0($s5) #contains a[0]
	li $t2, 0 # loop counter, we will increment this by 4 each time
	
	FORLOOP2:
	bge $t2, 128, ENDLOOP2
	add, $t3, $s5, $t2 #contains address for a[i]
	lw $t4, 0($t3) # a[i]
	lw $t5, 4($t3) # a[i + 1]
	move $t4, $t5 # a[i] = a[i + 1]
	sw $t4, 0($t3) #store the value in a[i]
	addi $t2, $t2, 4 # update loop counter
	j FORLOOP2
	
	ENDLOOP2:
	lw $t6 124($s5) # a[n-1]
	move $t6 $t1 # a[n - 1] = a[0]
	sw $t6, 124($s5)
	
	jr $ra


checkCollisionCar:
	
	# want to loop over the frog position and if any color is red or blue
	
	lw $a0, 0($sp) # pop frog coordinte parameter
	addi $sp, $sp, 4 # increase length of stack
	add $t0, $t0, $a0 # jump to position
	
	li $t1, 0 # horizontal counter
	li $t2, 0 # vertical counter
	FrogCheck: # create frog shape, square for now
	lw $t8, 0($t0) # load current color
	#check if value is red 
	beq $t8, 0xC10303, Collision
	addi $t1, $t1, 4
	addi $t0, $t0, 4
	beq $t1, 16, MoveToNextRow
	j FrogCheck
	MoveToNextRow:
	add $t0, $t0, 112 # jump to next row and repeat
	li $t1, 0
	add $t2, $t2, 1
	beq $t2, 4, finish
	j FrogLoop
	
	Collision:
	li $s7, 1
	j ENDCHECK
	
	ENDCHECK:
	jr $ra 

	
checkCollisionWater:
	
	# want to loop over the frog position and if any color is red or blue
	
	lw $a0, 0($sp) # pop frog coordinte parameter
	addi $sp, $sp, 4 # increase length of stack
	add $t0, $t0, $a0 # jump to position
	
	li $t1, 0 # horizontal counter
	li $t2, 0 # vertical counter
	FrogCheckLog: # create frog shape, square for now
	lw $t8, 0($t0) # load current color
	#check if value is blue
	beq $t8, 0x00F0FF, CollisionLog
	addi $t1, $t1, 4
	addi $t0, $t0, 4
	beq $t1, 16, MoveToNextRowLog
	j FrogCheckLog
	MoveToNextRowLog:
	add $t0, $t0, 112 # jump to next row and repeat
	li $t1, 0
	add $t2, $t2, 1
	beq $t2, 4, finish
	j FrogLoop
	
	CollisionLog:
	li $s7, 1
	j ENDCHECKLOG
	
	ENDCHECKLOG:
	jr $ra 

checkIfOnLog:
	
	add $t0, $t0, $a0 # jump to position
	#want to check if its on a log
	lw $t8, 0($t0) # load current color
	#check if value is brown
	beq $t8, 0xCC5C3E , UpdateFlag
	j FINISHMOVEMENT
	UpdateFlag:
	li $a3, 1
	
	
	
	
	
frogShift:	

	bge $s4, 1536 , ShiftFrogRight
	ble $s4, 1664 , ShiftFrogLeft
	j FINISHMOVEMENT
	
	ShiftFrogLeft:
	subi $s4, $s4, 4
	j FINISHMOVEMENT
	
	ShiftFrogRight:
	addi $s4, $s4, 4
	j FINISHMOVEMENT
	
	FINISHMOVEMENT:
	jr $ra
	
	
			
							


Exit:
	li $v0, 10 # terminate the program gracefully
	syscall

